// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package main

// Package try contains a Scala-like Try implementation. However you need
// to generate a type-specific version with github.com/cheekybits/genny. You
// can do so with a go generate tag such as:
//
// go:generate genny -in $PATH_TO_FILE/try_base.go -out your_file.go gen "string=string"

// StringTry represents the result of an operation that may or may not have succeeded
type StringTry struct {
	success bool
	value   string
	err     error
}

// ToStringTry converts a 2-tuple of value + error into a Try. The presense of a non-nil
// error value is what determines success or failure. This makes it ideal to wrap
// Go-style function calls to get a `Try`.
func ToStringTry(value string, err error) *StringTry {
	return &StringTry{
		success: err == nil,
		value:   value,
		err:     err,
	}
}

// NewStringSuccess creates a new succeeded Try
func NewStringSuccess(value string) *StringTry {
	return &StringTry{
		success: true,
		value:   value,
		err:     nil,
	}
}

// NewStringFailure creates a new failed Try
func NewStringFailure(err error) *StringTry {
	return &StringTry{
		success: false,
		err:     err,
	}
}

// IsSuccess tells if the Try is a successful Try, and thus holds a value that can be
// extraced with GetValue
func (t *StringTry) IsSuccess() bool {
	return t.success
}

// IsFailure tells if the Try is a failed Try, and thus holds an error that can be
// extraced with GetFailures
func (t *StringTry) IsFailure() bool {
	return !t.success
}

// GetValue returns a value for a successful Try. If the Try is not successful, it will
// panic, because this is totally the right thing to do.
func (t *StringTry) GetValue() string {
	if t.IsFailure() {
		panic("you do not know what you are doing")
	}
	return t.value
}

// GetFailure returns an error for a failed Try. If the Try is successful, it will
// panic, because this is totally the right thing to do.
func (t *StringTry) GetFailure() error {
	if t.IsSuccess() {
		panic("you do not know what you are doing")
	}
	return t.err
}

// Recover sets a default value of a failed Try (making it a success Try). A successful Try is always
// returned.
func (t *StringTry) Recover(f func() string) *StringTry {
	if !t.success {
		return &StringTry{
			success: true,
			value:   f(),
		}
	}
	return t
}

// RecoverWith provides a default function to call if the current Try is a failure. The return value
// is the result of the recover function or the original Try (if the Try is a success).
func (t *StringTry) RecoverWith(f func() *StringTry) *StringTry {
	if t.success {
		return t
	}
	return f()
}

// Package try contains a Scala-like Try implementation. However you need
// to generate a type-specific version with github.com/cheekybits/genny. You
// can do so with a go generate tag such as:
//
// go:generate genny -in $PATH_TO_FILE/try_base.go -out your_file.go gen "int=string"

// IntTry represents the result of an operation that may or may not have succeeded
type IntTry struct {
	success bool
	value   int
	err     error
}

// ToIntTry converts a 2-tuple of value + error into a Try. The presense of a non-nil
// error value is what determines success or failure. This makes it ideal to wrap
// Go-style function calls to get a `Try`.
func ToIntTry(value int, err error) *IntTry {
	return &IntTry{
		success: err == nil,
		value:   value,
		err:     err,
	}
}

// NewIntSuccess creates a new succeeded Try
func NewIntSuccess(value int) *IntTry {
	return &IntTry{
		success: true,
		value:   value,
		err:     nil,
	}
}

// NewIntFailure creates a new failed Try
func NewIntFailure(err error) *IntTry {
	return &IntTry{
		success: false,
		err:     err,
	}
}

// IsSuccess tells if the Try is a successful Try, and thus holds a value that can be
// extraced with GetValue
func (t *IntTry) IsSuccess() bool {
	return t.success
}

// IsFailure tells if the Try is a failed Try, and thus holds an error that can be
// extraced with GetFailures
func (t *IntTry) IsFailure() bool {
	return !t.success
}

// GetValue returns a value for a successful Try. If the Try is not successful, it will
// panic, because this is totally the right thing to do.
func (t *IntTry) GetValue() int {
	if t.IsFailure() {
		panic("you do not know what you are doing")
	}
	return t.value
}

// GetFailure returns an error for a failed Try. If the Try is successful, it will
// panic, because this is totally the right thing to do.
func (t *IntTry) GetFailure() error {
	if t.IsSuccess() {
		panic("you do not know what you are doing")
	}
	return t.err
}

// Recover sets a default value of a failed Try (making it a success Try). A successful Try is always
// returned.
func (t *IntTry) Recover(f func() int) *IntTry {
	if !t.success {
		return &IntTry{
			success: true,
			value:   f(),
		}
	}
	return t
}

// RecoverWith provides a default function to call if the current Try is a failure. The return value
// is the result of the recover function or the original Try (if the Try is a success).
func (t *IntTry) RecoverWith(f func() *IntTry) *IntTry {
	if t.success {
		return t
	}
	return f()
}
