// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package main

// Package try contains a Scala-like Try implementation. However you need
// to generate a type-specific version with github.com/cheekybits/genny. You
// can do so with a go generate tag such as:
//
// go:generate genny -in $PATH_TO_FILE/try_compose.go -out your_file.go gen "string=string, string=int"
//
// The compose file differs from the base file in that it handles compsition functions
// from one type of try to another using fu nctions like Map, FlatMap, etc. Note that you'll
// want to keep the package the same for the Try you are generating to/from.

// MapToString safely transforms the value within the Try or returns the same Try if it is failed
func (t *StringTry) MapToString(f func(string) string) *StringTry {
	if !t.success {
		return &StringTry{
			success: false,
			err:     t.err,
		}
	}
	return &StringTry{
		success: true,
		value:   f(t.value),
		err:     nil,
	}
}

// FlatMapToString transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed
func (t *StringTry) FlatMapToString(f func(string) *StringTry) *StringTry {
	if !t.success {
		return &StringTry{
			success: false,
			err:     t.err,
		}
	}
	return f(t.value)
}

// FlatMapWrapToString transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed. This differs from FlatMap in that it handles more go-style functions that
// return a value-error pair.
func (t *StringTry) FlatMapWrapToString(f func(string) (string, error)) *StringTry {
	if !t.success {
		return &StringTry{
			success: false,
			err:     t.err,
		}
	}
	return ToStringTry(f(t.value))
}

// Package try contains a Scala-like Try implementation. However you need
// to generate a type-specific version with github.com/cheekybits/genny. You
// can do so with a go generate tag such as:
//
// go:generate genny -in $PATH_TO_FILE/try_compose.go -out your_file.go gen "string=string, int=int"
//
// The compose file differs from the base file in that it handles compsition functions
// from one type of try to another using fu nctions like Map, FlatMap, etc. Note that you'll
// want to keep the package the same for the Try you are generating to/from.

// MapToInt safely transforms the value within the Try or returns the same Try if it is failed
func (t *StringTry) MapToInt(f func(string) int) *IntTry {
	if !t.success {
		return &IntTry{
			success: false,
			err:     t.err,
		}
	}
	return &IntTry{
		success: true,
		value:   f(t.value),
		err:     nil,
	}
}

// FlatMapToInt transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed
func (t *StringTry) FlatMapToInt(f func(string) *IntTry) *IntTry {
	if !t.success {
		return &IntTry{
			success: false,
			err:     t.err,
		}
	}
	return f(t.value)
}

// FlatMapWrapToInt transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed. This differs from FlatMap in that it handles more go-style functions that
// return a value-error pair.
func (t *StringTry) FlatMapWrapToInt(f func(string) (int, error)) *IntTry {
	if !t.success {
		return &IntTry{
			success: false,
			err:     t.err,
		}
	}
	return ToIntTry(f(t.value))
}

// Package try contains a Scala-like Try implementation. However you need
// to generate a type-specific version with github.com/cheekybits/genny. You
// can do so with a go generate tag such as:
//
// go:generate genny -in $PATH_TO_FILE/try_compose.go -out your_file.go gen "int=string, string=int"
//
// The compose file differs from the base file in that it handles compsition functions
// from one type of try to another using fu nctions like Map, FlatMap, etc. Note that you'll
// want to keep the package the same for the Try you are generating to/from.

// MapToString safely transforms the value within the Try or returns the same Try if it is failed
func (t *IntTry) MapToString(f func(int) string) *StringTry {
	if !t.success {
		return &StringTry{
			success: false,
			err:     t.err,
		}
	}
	return &StringTry{
		success: true,
		value:   f(t.value),
		err:     nil,
	}
}

// FlatMapToString transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed
func (t *IntTry) FlatMapToString(f func(int) *StringTry) *StringTry {
	if !t.success {
		return &StringTry{
			success: false,
			err:     t.err,
		}
	}
	return f(t.value)
}

// FlatMapWrapToString transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed. This differs from FlatMap in that it handles more go-style functions that
// return a value-error pair.
func (t *IntTry) FlatMapWrapToString(f func(int) (string, error)) *StringTry {
	if !t.success {
		return &StringTry{
			success: false,
			err:     t.err,
		}
	}
	return ToStringTry(f(t.value))
}

// Package try contains a Scala-like Try implementation. However you need
// to generate a type-specific version with github.com/cheekybits/genny. You
// can do so with a go generate tag such as:
//
// go:generate genny -in $PATH_TO_FILE/try_compose.go -out your_file.go gen "int=string, int=int"
//
// The compose file differs from the base file in that it handles compsition functions
// from one type of try to another using fu nctions like Map, FlatMap, etc. Note that you'll
// want to keep the package the same for the Try you are generating to/from.

// MapToInt safely transforms the value within the Try or returns the same Try if it is failed
func (t *IntTry) MapToInt(f func(int) int) *IntTry {
	if !t.success {
		return &IntTry{
			success: false,
			err:     t.err,
		}
	}
	return &IntTry{
		success: true,
		value:   f(t.value),
		err:     nil,
	}
}

// FlatMapToInt transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed
func (t *IntTry) FlatMapToInt(f func(int) *IntTry) *IntTry {
	if !t.success {
		return &IntTry{
			success: false,
			err:     t.err,
		}
	}
	return f(t.value)
}

// FlatMapWrapToInt transforms the Try with a function that returns another Try, or cascades the original
// Try if it is failed. This differs from FlatMap in that it handles more go-style functions that
// return a value-error pair.
func (t *IntTry) FlatMapWrapToInt(f func(int) (int, error)) *IntTry {
	if !t.success {
		return &IntTry{
			success: false,
			err:     t.err,
		}
	}
	return ToIntTry(f(t.value))
}
