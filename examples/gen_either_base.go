// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package main

// Package contains an Either type which is like a 2-tuple containing values of two different
// types with the ability to compose and chain values and functions together depending on the
// type. This is a very popular way to do validation where the "left" is always the error type.
//
// Note that this Either _is_ right-biased meaning that operations that do not work on a
// particular side are said to be "biased", such as Map and FlatMap. These assume the existence
// of a "left" to transform, or cascade the "right" value as if it were the error in a Try-type.
//
// go:generate genny -in $PATH_TO_FILE/either_base.go -out your_file.go gen "A=string B=int"

// EitherStringOrString is a container for one of 2 values. Each value can be composed separately
// to define multiple code-paths without excessive branching in client-code.
type EitherStringOrString struct {
	left   string
	right  string
	isLeft bool
}

// NewEitherStringOrStringLeft is a way to create an either-value that has a left-value
// Note the left/right'ness cannot be changed once created
func NewEitherStringOrStringLeft(left string) *EitherStringOrString {
	return &EitherStringOrString{
		left:   left,
		isLeft: true,
	}
}

// NewEitherStringOrStringRight is a way to create an either-value that has a right-value
// Note that the left/right'ness cannot be changed once created
func NewEitherStringOrStringRight(right string) *EitherStringOrString {
	return &EitherStringOrString{
		right:  right,
		isLeft: false,
	}
}

// IsLeft checks the either type for left'ness
func (e *EitherStringOrString) IsLeft() bool {
	return e.isLeft
}

// IsRight checks the either type for right'ness
func (e *EitherStringOrString) IsRight() bool {
	return !e.isLeft
}

// GetLeftOrElse returns the left value or a default if the either is not a left-either
func (e *EitherStringOrString) GetLeftOrElse(defaultLeft string) string {
	if e.isLeft {
		return e.left
	}
	return defaultLeft
}

// GetRightOrElse returns the right value or a default if the either is not a right-either
func (e *EitherStringOrString) GetRightOrElse(defaultRight string) string {
	if e.isLeft {
		return defaultRight
	}
	return e.right
}

// Package contains an Either type which is like a 2-tuple containing values of two different
// types with the ability to compose and chain values and functions together depending on the
// type. This is a very popular way to do validation where the "left" is always the error type.
//
// Note that this Either _is_ right-biased meaning that operations that do not work on a
// particular side are said to be "biased", such as Map and FlatMap. These assume the existence
// of a "left" to transform, or cascade the "right" value as if it were the error in a Try-type.
//
// go:generate genny -in $PATH_TO_FILE/either_base.go -out your_file.go gen "A=string B=int"

// EitherStringOrInt is a container for one of 2 values. Each value can be composed separately
// to define multiple code-paths without excessive branching in client-code.
type EitherStringOrInt struct {
	left   string
	right  int
	isLeft bool
}

// NewEitherStringOrIntLeft is a way to create an either-value that has a left-value
// Note the left/right'ness cannot be changed once created
func NewEitherStringOrIntLeft(left string) *EitherStringOrInt {
	return &EitherStringOrInt{
		left:   left,
		isLeft: true,
	}
}

// NewEitherStringOrIntRight is a way to create an either-value that has a right-value
// Note that the left/right'ness cannot be changed once created
func NewEitherStringOrIntRight(right int) *EitherStringOrInt {
	return &EitherStringOrInt{
		right:  right,
		isLeft: false,
	}
}

// IsLeft checks the either type for left'ness
func (e *EitherStringOrInt) IsLeft() bool {
	return e.isLeft
}

// IsRight checks the either type for right'ness
func (e *EitherStringOrInt) IsRight() bool {
	return !e.isLeft
}

// GetLeftOrElse returns the left value or a default if the either is not a left-either
func (e *EitherStringOrInt) GetLeftOrElse(defaultLeft string) string {
	if e.isLeft {
		return e.left
	}
	return defaultLeft
}

// GetRightOrElse returns the right value or a default if the either is not a right-either
func (e *EitherStringOrInt) GetRightOrElse(defaultRight int) int {
	if e.isLeft {
		return defaultRight
	}
	return e.right
}

// Package contains an Either type which is like a 2-tuple containing values of two different
// types with the ability to compose and chain values and functions together depending on the
// type. This is a very popular way to do validation where the "left" is always the error type.
//
// Note that this Either _is_ right-biased meaning that operations that do not work on a
// particular side are said to be "biased", such as Map and FlatMap. These assume the existence
// of a "left" to transform, or cascade the "right" value as if it were the error in a Try-type.
//
// go:generate genny -in $PATH_TO_FILE/either_base.go -out your_file.go gen "A=string B=int"

// EitherIntOrString is a container for one of 2 values. Each value can be composed separately
// to define multiple code-paths without excessive branching in client-code.
type EitherIntOrString struct {
	left   int
	right  string
	isLeft bool
}

// NewEitherIntOrStringLeft is a way to create an either-value that has a left-value
// Note the left/right'ness cannot be changed once created
func NewEitherIntOrStringLeft(left int) *EitherIntOrString {
	return &EitherIntOrString{
		left:   left,
		isLeft: true,
	}
}

// NewEitherIntOrStringRight is a way to create an either-value that has a right-value
// Note that the left/right'ness cannot be changed once created
func NewEitherIntOrStringRight(right string) *EitherIntOrString {
	return &EitherIntOrString{
		right:  right,
		isLeft: false,
	}
}

// IsLeft checks the either type for left'ness
func (e *EitherIntOrString) IsLeft() bool {
	return e.isLeft
}

// IsRight checks the either type for right'ness
func (e *EitherIntOrString) IsRight() bool {
	return !e.isLeft
}

// GetLeftOrElse returns the left value or a default if the either is not a left-either
func (e *EitherIntOrString) GetLeftOrElse(defaultLeft int) int {
	if e.isLeft {
		return e.left
	}
	return defaultLeft
}

// GetRightOrElse returns the right value or a default if the either is not a right-either
func (e *EitherIntOrString) GetRightOrElse(defaultRight string) string {
	if e.isLeft {
		return defaultRight
	}
	return e.right
}

// Package contains an Either type which is like a 2-tuple containing values of two different
// types with the ability to compose and chain values and functions together depending on the
// type. This is a very popular way to do validation where the "left" is always the error type.
//
// Note that this Either _is_ right-biased meaning that operations that do not work on a
// particular side are said to be "biased", such as Map and FlatMap. These assume the existence
// of a "left" to transform, or cascade the "right" value as if it were the error in a Try-type.
//
// go:generate genny -in $PATH_TO_FILE/either_base.go -out your_file.go gen "A=string B=int"

// EitherIntOrInt is a container for one of 2 values. Each value can be composed separately
// to define multiple code-paths without excessive branching in client-code.
type EitherIntOrInt struct {
	left   int
	right  int
	isLeft bool
}

// NewEitherIntOrIntLeft is a way to create an either-value that has a left-value
// Note the left/right'ness cannot be changed once created
func NewEitherIntOrIntLeft(left int) *EitherIntOrInt {
	return &EitherIntOrInt{
		left:   left,
		isLeft: true,
	}
}

// NewEitherIntOrIntRight is a way to create an either-value that has a right-value
// Note that the left/right'ness cannot be changed once created
func NewEitherIntOrIntRight(right int) *EitherIntOrInt {
	return &EitherIntOrInt{
		right:  right,
		isLeft: false,
	}
}

// IsLeft checks the either type for left'ness
func (e *EitherIntOrInt) IsLeft() bool {
	return e.isLeft
}

// IsRight checks the either type for right'ness
func (e *EitherIntOrInt) IsRight() bool {
	return !e.isLeft
}

// GetLeftOrElse returns the left value or a default if the either is not a left-either
func (e *EitherIntOrInt) GetLeftOrElse(defaultLeft int) int {
	if e.isLeft {
		return e.left
	}
	return defaultLeft
}

// GetRightOrElse returns the right value or a default if the either is not a right-either
func (e *EitherIntOrInt) GetRightOrElse(defaultRight int) int {
	if e.isLeft {
		return defaultRight
	}
	return e.right
}
